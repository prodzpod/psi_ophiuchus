buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
    }
}
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'idea'
apply plugin: 'maven'

def configFile = file('gradle.properties')
def config = parseConfig(configFile)

version = "${config.version}.${config.build}"
group = "kr.o_r.${config.author}.${config.id}" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = config.id

def spec = copySpec {
    from('template') {
        filter {
            it.replace('%MODID%', config.id)
                    .replace('%MODNAME%', config.name)
                    .replace('%VERSION%', version)
        }
    }
}
task replaceModClass(type: Copy) {
    outputs.upToDateWhen { false }
    into "src/main/java/kr/o_r/prodzpod/ophiuchus/common/util"
    include 'ThisMod.java'
    with spec
}
task replaceModToml(type: Copy) {
    outputs.upToDateWhen { false }
    into "src/main/resources/META-INF"
    include 'mods.toml'
    with spec
}
task incrementBuildNumber {
    doLast {
        config.build = (config.build.toString().toInteger()) + 1
        configFile.withWriter {
            config.toProperties().store(it, "")
        }
    }
}
compileJava.dependsOn replaceModClass
compileJava.dependsOn replaceModToml
compileJava.dependsOn incrementBuildNumber

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
    mappings channel: 'snapshot', version: config.mcp
    accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    runs.all { variant ->
        variant.workingDirectory project.file('run')
        variant.property 'forge.logging.console.level', 'debug'
        variant.mods {
            ophiuchus { // TODO: change this with a [config.name], the expected method does not work
                source sourceSets.main
            }
        }
    }
    runs {
        client {
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
        }
        server {
            singleInstance(true)
        }
        data {
            property 'forge.logging.markers', 'REGISTRIES,REGISTRYDUMP'
            properties 'fml.earlyprogresswindow': 'false'
            args "--mod", config.name, "--all", "--output", "\"" + file("src/generated/resources").toString() + "\"", "--validate", "--existing", "\"" + sourceSets.main.resources.srcDirs[0] + "\""
        }
    }
}
repositories {
    maven { url = "http://dvs1.progwml6.com/files/maven" }
    maven { url = "https://maven.blamejared.com/" }
}

dependencies {
    minecraft "net.minecraftforge:forge:${config.mc}-${config.forge}"
    compile     fg.deobf("vazkii.psi:Psi:${config.psi}")
    compileOnly fg.deobf("vazkii.patchouli:Patchouli:${config.mc}-${config.patchouli}:api")
    runtimeOnly fg.deobf("vazkii.patchouli:Patchouli:${config.mc}-${config.patchouli}")
    compileOnly fg.deobf("mezz.jei:jei-${config.mc}:${config.jei}:api")
    runtimeOnly fg.deobf("mezz.jei:jei-${config.mc}:${config.jei}")
}

sourceSets.main.resources {
    srcDirs += ['src/generated/resources']
    println srcDirs
}

// Example for how to get properties into the manifest for reading by the runtime..
jar {
    manifest {
        attributes([
                "Specification-Title": config.id,
                "Specification-Vendor": config.author,
                "Specification-Version": "1", // We are version 1 of ourselves
                "Implementation-Title": config.name,
                "Implementation-Version": version,
                "Implementation-Vendor" : config.author,
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

jar.finalizedBy('reobfJar')
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
//publish.dependsOn('reobfJar')

//publishing {
//    publications {
//        mavenJava(MavenPublication) {
//            artifact jar
//        }
//    }
//    repositories {
//        maven {
//            url "file:///${project.projectDir}/mcmodsrepo"
//        }
//    }
//}

static def parseConfig(File config) {
    config.withReader {
        def prop = new Properties()
        prop.load(it)
        return (new ConfigSlurper().parse(prop))
    }
}

defaultTasks 'clean', 'build', 'runClient'